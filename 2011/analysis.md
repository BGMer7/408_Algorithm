2011年42题（15分）

一个长度为`L(L>=1)`的升序序列S，处在`ceil(L/2)`个位置的数称为S的中位数。例如`S1=<11, 13, 15, 17, 19>`，则`S1`的中位数为15。两个序列的中位数是含他们所有元素的升序序列的中位数。例如`S2=<2, 4, 6, 8, 10>`，则`S1`和`S2`的中位数是11。

现有两个等长的升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求：

（1）给出算法的基本设计思想。（5分）
（2）根据设计思想，采用C/C++/Java语言描述，关键之处给出注释。（8分）
（3）说明你所设计算法的时间复杂度和空间复杂度。（2分）

这道题类似于`leetcode`的`hard`题，https://leetcode.cn/problems/median-of-two-sorted-arrays/description/，原题出自《算法导论》第三版9.3-8，现《算法导论》第四版9.3-10。



>本题为408史上最难算法题，力扣困难难度的算法题，408算法题出困难难度的概率较低，理论上8~10年出现一次，同学们平时还是主要把简单和中等难度的算法题掌握好即可。
>
>评：王道给出的参考答案中代码部分出现错误，错误出现在最后一个else分支，其中两行代码均错误。
>
>错误代码为：
>
>```c
>else { // 若元素个数为偶数
>    d1 = m1 + 1;  // 舍弃A中间点以后的部分且保留中点
>    s2 = m2;  // 舍弃B中间点及中间点以前的部分
>}
>```
>
>正确代码为：
>
>```c
>else { // 若元素个数为偶数
>    d1 = m1;  // 舍弃A中间点以后的部分且保留中点
>    s2 = m2 + 1;  // 舍弃B中间点及中间点以前的部分
>}
>```
>
>本人校正如下：
>
>```c
>int Search(int A[], int B[], int n) { // n即为序列长度L
>    int s1 = 0, d1 = n - 1, m1, s2 = 0, d2 = n - 1, m2;
>    while(s1 != d1 || s2 != d2) {
>        m1 = (s1 + d1) / 2;
>        m2 = (s2 + d2) / 2;
>        if (A[m1] == B[m2]) {
>             return A[m1];
>        } else if (A[m1] < B[m2]) { 
>            // 分别考虑奇数和偶数，保持两个子数组元素个数相等
>            if ((s1 + d1) % 2 == 0) { // 若元素个数为奇数
>                 s1 = m1;  // 舍弃A中间点以前的部分且保留中点
>                 d2 = m2;  // 舍弃B中间点以后的部分且保留中点
>            } else { // 若元素个数为偶数
>                 s1 = m1 + 1;  // 舍弃A中间点及中间点以前的部分
>                 d2 = m2;  // 舍弃B中间点以后的部分且保留中点
>            }
>        } else {
>            // 分别考虑奇数和偶数，保持两个子数组元素个数相等
>            if ((s1 + d1) % 2 == 0) { // 若元素个数为奇数
>                 d1 = m1;  // 舍弃A中间点以后的部分且保留中点
>                 s2 = m2;  // 舍弃B中间点以前的部分且保留中点
>            } else { // 若元素个数为偶数
>                 d1 = m1;  // 舍弃A中间点以后的部分且保留中点
>                 s2 = m2 + 1;  // 舍弃B中间点及中间点以前的部分
>            }
>        }
>    }
>    return A[s1] < B[s2] ? A[s1] : B[s2];
>}
>```
>
>写代码应该非常严谨，王道虎头蛇尾的做法不值得学习。





根据千叶原的整理，归为六个方法。
